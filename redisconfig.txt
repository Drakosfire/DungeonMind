Setting up Redis to store and retrieve the `state` parameter can provide a robust solution for managing OAuth flows, especially when session cookies are unreliable due to browser partitioning. Here’s how to set it up in your FastAPI application.

### Step 1: Install Redis and Redis-Py

First, install Redis on your local machine if you haven’t already. For Ubuntu:

```bash
sudo apt update
sudo apt install redis-server
```

You can start and enable Redis:

```bash
sudo systemctl start redis
sudo systemctl enable redis
```

Then, install the Python Redis client:

```bash
pip install redis
```

### Step 2: Configure Redis in FastAPI

We’ll connect to Redis from FastAPI to store and retrieve the `state` value.

1. **Import Redis and Initialize the Connection**:
   In your `app.py` or a separate `redis_client.py` file, set up a connection to Redis.

   ```python
   import redis
   import os

   # Initialize Redis connection
   redis_host = os.getenv("REDIS_HOST", "localhost")
   redis_port = os.getenv("REDIS_PORT", 6379)
   redis_client = redis.Redis(host=redis_host, port=redis_port, decode_responses=True)
   ```

2. **Configure Expiration for State Values**:
   OAuth state values should be short-lived for security purposes. Let’s set an expiration time (e.g., 5 minutes) for the state keys in Redis.

### Step 3: Modify the `/login` and `/callback` Endpoints to Use Redis

In your `auth_router.py`, replace the session storage of `state` with Redis storage.

#### Updated `/login` Endpoint

In the `/login` route, generate a random state value, store it in Redis, and send it as a parameter to Google:

```python
import secrets
from datetime import timedelta

# Expiration time for state values (e.g., 5 minutes)
STATE_EXPIRATION = 300  # 5 minutes in seconds

@router.get('/login')
async def login(request: Request, prompt: str = "consent"):
    redirect_uri = CONFIG['OAUTH_REDIRECT_URI']
    
    # Generate a random state value
    state = secrets.token_urlsafe(16)
    logger.debug(f"Generated state: {state}")

    # Store the state in Redis with an expiration time
    redis_client.setex(f"oauth_state:{state}", STATE_EXPIRATION, "valid")
    
    return await oauth.google.authorize_redirect(request, redirect_uri, state=state, prompt=prompt)
```

- `setex` stores the `state` in Redis with a key prefix (e.g., `oauth_state:`) and sets it to expire in 5 minutes.
- You can adjust `STATE_EXPIRATION` to your preferred value.

#### Updated `/callback` Endpoint

In the `/callback` route, retrieve and verify the `state` from Redis instead of the session:

```python
@router.get('/callback')
async def auth_callback(request: Request):
    try:
        # Retrieve the state from the request and Redis
        request_state = request.query_params.get('state')
        
        if not request_state:
            raise HTTPException(status_code=400, detail="Missing state parameter")
        
        # Check if the state exists in Redis
        state_valid = redis_client.get(f"oauth_state:{request_state}")
        if not state_valid:
            logger.error("State mismatch or expired state")
            raise HTTPException(status_code=400, detail="State mismatch or expired state")
        
        # Delete the state from Redis once it’s verified to prevent reuse
        redis_client.delete(f"oauth_state:{request_state}")
        
        # Exchange the authorization code for an access token
        token = await oauth.google.authorize_access_token(request)
        user = token.get('userinfo')
        if user:
            request.session['user'] = dict(user)
            request.session['exp'] = (datetime.utcnow() + timedelta(hours=1)).isoformat()
            return RedirectResponse(url='/')
        else:
            raise HTTPException(status_code=400, detail="Failed to get user info")
            
    except Exception as e:
        logger.error(f"Error during authorization: {str(e)}", exc_info=True)
        raise HTTPException(status_code=400, detail=str(e))
```

- **Retrieve the state** from Redis using `get`. If it doesn’t exist, return a `400` error due to a state mismatch or expiration.
- **Delete the state** immediately after verifying it to prevent reuse (mitigates replay attacks).

### Step 4: Test the Flow

1. **Start Redis** if it’s not already running:

   ```bash
   sudo systemctl start redis
   ```

2. **Run your FastAPI app**:

   ```bash
   uvicorn app:app --host 0.0.0.0 --port 7860
   ```

3. **Initiate the login flow** from your app and follow the OAuth redirection steps. Monitor the logs to ensure the `state` is correctly stored and retrieved from Redis.

### Optional: Add Redis Configuration to `.env` File

To keep your code flexible, add Redis configurations to your `.env` file:

```plaintext
REDIS_HOST=localhost
REDIS_PORT=6379
```

Then, load these in `app.py` or `auth_router.py`:

```python
from dotenv import load_dotenv
load_dotenv()  # Load environment variables from .env file

redis_host = os.getenv("REDIS_HOST", "localhost")
redis_port = int(os.getenv("REDIS_PORT", 6379))
```

### Summary

- **Store `state` in Redis** instead of relying on session cookies.
- **Set an expiration** for each `state` in Redis to enhance security.
- **Verify and delete `state`** from Redis in the `/callback` route.
  
This setup should allow the OAuth flow to work reliably, avoiding issues with state partitioning and cookie accessibility. Let me know if this resolves the issue, or if any additional adjustments are needed!